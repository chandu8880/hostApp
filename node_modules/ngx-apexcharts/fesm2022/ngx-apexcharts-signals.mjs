import * as i0 from '@angular/core';
import { input, viewChild, signal, afterNextRender, afterEveryRender, inject, DestroyRef, ChangeDetectionStrategy, Component, Directive, NgModule } from '@angular/core';

/* eslint-disable @typescript-eslint/no-explicit-any */
class ChartComponent {
    constructor() {
        this.chart = input();
        this.annotations = input();
        this.colors = input();
        this.dataLabels = input();
        this.series = input();
        this.stroke = input();
        this.labels = input();
        this.legend = input();
        this.markers = input();
        this.noData = input();
        this.fill = input();
        this.tooltip = input();
        this.plotOptions = input();
        this.responsive = input();
        this.xaxis = input();
        this.yaxis = input();
        this.forecastDataPoints = input();
        this.grid = input();
        this.states = input();
        this.title = input();
        this.subtitle = input();
        this.theme = input();
        this.autoUpdateSeries = input(true);
        this.chartElement = viewChild.required("chart");
        this.hasPendingLoad = signal(false);
        afterNextRender(async () => {
            this.hasPendingLoad.set(true);
            const ApexCharts = (await import('apexcharts')).default;
            const options = this.buildOptions();
            this.chartObj = new ApexCharts(this.chartElement().nativeElement, options);
            window.ApexCharts = ApexCharts;
            await this.render();
            this.hasPendingLoad.set(true);
        });
        afterEveryRender(async () => {
            if (this.hasPendingLoad() === true) {
                return;
            }
            this.hasPendingLoad.set(true);
            this.chartObj?.destroy();
            const ApexCharts = (await import('apexcharts')).default;
            const options = this.buildOptions();
            this.chartObj = new ApexCharts(this.chartElement().nativeElement, options);
            await this.render();
            this.hasPendingLoad.set(false);
        });
        const destroyRef = inject(DestroyRef);
        destroyRef.onDestroy(() => this.chartObj?.destroy());
    }
    ngOnDestroy() {
        this.destroy();
    }
    render() {
        return this.chartObj?.render();
    }
    updateOptions(options, redrawPaths, animate, updateSyncedCharts) {
        return this.chartObj?.updateOptions(options, redrawPaths, animate, updateSyncedCharts);
    }
    updateSeries(newSeries, animate) {
        return this.chartObj?.updateSeries(newSeries, animate);
    }
    appendSeries(newSeries, animate) {
        this.chartObj?.appendSeries(newSeries, animate);
    }
    appendData(newData) {
        this.chartObj?.appendData(newData);
    }
    toggleSeries(seriesName) {
        return this.chartObj?.toggleSeries(seriesName);
    }
    showSeries(seriesName) {
        this.chartObj?.showSeries(seriesName);
    }
    hideSeries(seriesName) {
        this.chartObj?.hideSeries(seriesName);
    }
    resetSeries() {
        this.chartObj?.resetSeries();
    }
    zoomX(min, max) {
        this.chartObj?.zoomX(min, max);
    }
    toggleDataPointSelection(seriesIndex, dataPointIndex) {
        this.chartObj?.toggleDataPointSelection(seriesIndex, dataPointIndex);
    }
    destroy() {
        this.chartObj?.destroy();
    }
    setLocale(localeName) {
        this.chartObj?.setLocale(localeName);
    }
    paper() {
        this.chartObj?.paper();
    }
    addXaxisAnnotation(options, pushToMemory, context) {
        this.chartObj?.addXaxisAnnotation(options, pushToMemory, context);
    }
    addYaxisAnnotation(options, pushToMemory, context) {
        this.chartObj?.addYaxisAnnotation(options, pushToMemory, context);
    }
    addPointAnnotation(options, pushToMemory, context) {
        this.chartObj?.addPointAnnotation(options, pushToMemory, context);
    }
    removeAnnotation(id, options) {
        this.chartObj?.removeAnnotation(id, options);
    }
    clearAnnotations(options) {
        this.chartObj?.clearAnnotations(options);
    }
    dataURI(options) {
        return this.chartObj?.dataURI(options);
    }
    buildOptions() {
        const options = {};
        if (this.annotations()) {
            options.annotations = this.annotations();
        }
        if (this.chart()) {
            options.chart = this.chart();
        }
        if (this.colors()) {
            options.colors = this.colors();
        }
        if (this.dataLabels()) {
            options.dataLabels = this.dataLabels();
        }
        if (this.series()) {
            options.series = this.series();
        }
        if (this.stroke()) {
            options.stroke = this.stroke();
        }
        if (this.labels()) {
            options.labels = this.labels();
        }
        if (this.legend()) {
            options.legend = this.legend();
        }
        if (this.fill()) {
            options.fill = this.fill();
        }
        if (this.tooltip()) {
            options.tooltip = this.tooltip();
        }
        if (this.plotOptions()) {
            options.plotOptions = this.plotOptions();
        }
        if (this.responsive()) {
            options.responsive = this.responsive();
        }
        if (this.markers()) {
            options.markers = this.markers();
        }
        if (this.noData()) {
            options.noData = this.noData();
        }
        if (this.xaxis()) {
            options.xaxis = this.xaxis();
        }
        if (this.yaxis()) {
            options.yaxis = this.yaxis();
        }
        if (this.forecastDataPoints()) {
            options.forecastDataPoints = this.forecastDataPoints();
        }
        if (this.grid()) {
            options.grid = this.grid();
        }
        if (this.states()) {
            options.states = this.states();
        }
        if (this.title()) {
            options.title = this.title();
        }
        if (this.subtitle()) {
            options.subtitle = this.subtitle();
        }
        if (this.theme()) {
            options.theme = this.theme();
        }
        return options;
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.0", ngImport: i0, type: ChartComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    /** @nocollapse */ static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "20.0.0", type: ChartComponent, isStandalone: true, selector: "apx-chart", inputs: { chart: { classPropertyName: "chart", publicName: "chart", isSignal: true, isRequired: false, transformFunction: null }, annotations: { classPropertyName: "annotations", publicName: "annotations", isSignal: true, isRequired: false, transformFunction: null }, colors: { classPropertyName: "colors", publicName: "colors", isSignal: true, isRequired: false, transformFunction: null }, dataLabels: { classPropertyName: "dataLabels", publicName: "dataLabels", isSignal: true, isRequired: false, transformFunction: null }, series: { classPropertyName: "series", publicName: "series", isSignal: true, isRequired: false, transformFunction: null }, stroke: { classPropertyName: "stroke", publicName: "stroke", isSignal: true, isRequired: false, transformFunction: null }, labels: { classPropertyName: "labels", publicName: "labels", isSignal: true, isRequired: false, transformFunction: null }, legend: { classPropertyName: "legend", publicName: "legend", isSignal: true, isRequired: false, transformFunction: null }, markers: { classPropertyName: "markers", publicName: "markers", isSignal: true, isRequired: false, transformFunction: null }, noData: { classPropertyName: "noData", publicName: "noData", isSignal: true, isRequired: false, transformFunction: null }, fill: { classPropertyName: "fill", publicName: "fill", isSignal: true, isRequired: false, transformFunction: null }, tooltip: { classPropertyName: "tooltip", publicName: "tooltip", isSignal: true, isRequired: false, transformFunction: null }, plotOptions: { classPropertyName: "plotOptions", publicName: "plotOptions", isSignal: true, isRequired: false, transformFunction: null }, responsive: { classPropertyName: "responsive", publicName: "responsive", isSignal: true, isRequired: false, transformFunction: null }, xaxis: { classPropertyName: "xaxis", publicName: "xaxis", isSignal: true, isRequired: false, transformFunction: null }, yaxis: { classPropertyName: "yaxis", publicName: "yaxis", isSignal: true, isRequired: false, transformFunction: null }, forecastDataPoints: { classPropertyName: "forecastDataPoints", publicName: "forecastDataPoints", isSignal: true, isRequired: false, transformFunction: null }, grid: { classPropertyName: "grid", publicName: "grid", isSignal: true, isRequired: false, transformFunction: null }, states: { classPropertyName: "states", publicName: "states", isSignal: true, isRequired: false, transformFunction: null }, title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, subtitle: { classPropertyName: "subtitle", publicName: "subtitle", isSignal: true, isRequired: false, transformFunction: null }, theme: { classPropertyName: "theme", publicName: "theme", isSignal: true, isRequired: false, transformFunction: null }, autoUpdateSeries: { classPropertyName: "autoUpdateSeries", publicName: "autoUpdateSeries", isSignal: true, isRequired: false, transformFunction: null } }, viewQueries: [{ propertyName: "chartElement", first: true, predicate: ["chart"], descendants: true, isSignal: true }], exportAs: ["apexChat"], ngImport: i0, template: "<div #chart></div>", isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.0", ngImport: i0, type: ChartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "apx-chart",
                    template: "<div #chart></div>",
                    exportAs: "apexChat",
                    standalone: true,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: () => [] });

/* eslint-disable @typescript-eslint/no-explicit-any */
class NgxApexchartsDirective {
    constructor(el) {
        this.el = el;
        this.chart = input();
        this.annotations = input();
        this.colors = input();
        this.dataLabels = input();
        this.series = input();
        this.stroke = input();
        this.labels = input();
        this.legend = input();
        this.markers = input();
        this.noData = input();
        this.fill = input();
        this.tooltip = input();
        this.plotOptions = input();
        this.responsive = input();
        this.xaxis = input();
        this.yaxis = input();
        this.forecastDataPoints = input();
        this.grid = input();
        this.states = input();
        this.title = input();
        this.subtitle = input();
        this.theme = input();
        this.autoUpdateSeries = input(true);
        this.hasPendingLoad = signal(false);
        this.destroyRef = inject(DestroyRef);
        afterNextRender(async () => {
            this.hasPendingLoad.set(true);
            const ApexCharts = (await import('apexcharts')).default;
            const options = this.buildOptions();
            this.chartObj = new ApexCharts(this.el.nativeElement, options);
            window.ApexCharts = ApexCharts;
            await this.render();
            this.hasPendingLoad.set(false);
        });
        afterEveryRender(async () => {
            if (this.hasPendingLoad()) {
                return;
            }
            this.hasPendingLoad.set(true);
            this.chartObj?.destroy();
            const ApexCharts = (await import('apexcharts')).default;
            const options = this.buildOptions();
            this.chartObj = new ApexCharts(this.el.nativeElement, options);
            await this.render();
            this.hasPendingLoad.set(false);
        });
        this.destroyRef.onDestroy(() => {
            this.chartObj?.destroy();
        });
    }
    render() {
        if (this.chartObj) {
            return this.chartObj.render();
        }
        return Promise.resolve();
    }
    updateOptions(options, redrawPaths, animate, updateSyncedCharts) {
        return this.chartObj?.updateOptions(options, redrawPaths, animate, updateSyncedCharts);
    }
    updateSeries(newSeries, animate) {
        return this.chartObj?.updateSeries(newSeries, animate);
    }
    appendSeries(newSeries, animate) {
        this.chartObj?.appendSeries(newSeries, animate);
    }
    appendData(newData) {
        this.chartObj?.appendData(newData);
    }
    toggleSeries(seriesName) {
        return this.chartObj?.toggleSeries(seriesName);
    }
    showSeries(seriesName) {
        this.chartObj?.showSeries(seriesName);
    }
    hideSeries(seriesName) {
        this.chartObj?.hideSeries(seriesName);
    }
    resetSeries() {
        this.chartObj?.resetSeries();
    }
    zoomX(min, max) {
        this.chartObj?.zoomX(min, max);
    }
    toggleDataPointSelection(seriesIndex, dataPointIndex) {
        this.chartObj?.toggleDataPointSelection(seriesIndex, dataPointIndex);
    }
    destroy() {
        this.chartObj?.destroy();
    }
    setLocale(localeName) {
        this.chartObj?.setLocale(localeName);
    }
    paper() {
        this.chartObj?.paper();
    }
    addXaxisAnnotation(options, pushToMemory, context) {
        this.chartObj?.addXaxisAnnotation(options, pushToMemory, context);
    }
    addYaxisAnnotation(options, pushToMemory, context) {
        this.chartObj?.addYaxisAnnotation(options, pushToMemory, context);
    }
    addPointAnnotation(options, pushToMemory, context) {
        this.chartObj?.addPointAnnotation(options, pushToMemory, context);
    }
    removeAnnotation(id, options) {
        this.chartObj?.removeAnnotation(id, options);
    }
    clearAnnotations(options) {
        this.chartObj?.clearAnnotations(options);
    }
    dataURI(options) {
        return this.chartObj?.dataURI(options);
    }
    buildOptions() {
        const options = {};
        if (this.annotations()) {
            options.annotations = this.annotations();
        }
        if (this.chart()) {
            options.chart = this.chart();
        }
        if (this.colors()) {
            options.colors = this.colors();
        }
        if (this.dataLabels()) {
            options.dataLabels = this.dataLabels();
        }
        if (this.series()) {
            options.series = this.series();
        }
        if (this.stroke()) {
            options.stroke = this.stroke();
        }
        if (this.labels()) {
            options.labels = this.labels();
        }
        if (this.legend()) {
            options.legend = this.legend();
        }
        if (this.fill()) {
            options.fill = this.fill();
        }
        if (this.tooltip()) {
            options.tooltip = this.tooltip();
        }
        if (this.plotOptions()) {
            options.plotOptions = this.plotOptions();
        }
        if (this.responsive()) {
            options.responsive = this.responsive();
        }
        if (this.markers()) {
            options.markers = this.markers();
        }
        if (this.noData()) {
            options.noData = this.noData();
        }
        if (this.xaxis()) {
            options.xaxis = this.xaxis();
        }
        if (this.yaxis()) {
            options.yaxis = this.yaxis();
        }
        if (this.forecastDataPoints()) {
            options.forecastDataPoints = this.forecastDataPoints();
        }
        if (this.grid()) {
            options.grid = this.grid();
        }
        if (this.states()) {
            options.states = this.states();
        }
        if (this.title()) {
            options.title = this.title();
        }
        if (this.subtitle()) {
            options.subtitle = this.subtitle();
        }
        if (this.theme()) {
            options.theme = this.theme();
        }
        return options;
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.0", ngImport: i0, type: NgxApexchartsDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    /** @nocollapse */ static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "20.0.0", type: NgxApexchartsDirective, isStandalone: true, selector: "[apxChart]", inputs: { chart: { classPropertyName: "chart", publicName: "chart", isSignal: true, isRequired: false, transformFunction: null }, annotations: { classPropertyName: "annotations", publicName: "annotations", isSignal: true, isRequired: false, transformFunction: null }, colors: { classPropertyName: "colors", publicName: "colors", isSignal: true, isRequired: false, transformFunction: null }, dataLabels: { classPropertyName: "dataLabels", publicName: "dataLabels", isSignal: true, isRequired: false, transformFunction: null }, series: { classPropertyName: "series", publicName: "series", isSignal: true, isRequired: false, transformFunction: null }, stroke: { classPropertyName: "stroke", publicName: "stroke", isSignal: true, isRequired: false, transformFunction: null }, labels: { classPropertyName: "labels", publicName: "labels", isSignal: true, isRequired: false, transformFunction: null }, legend: { classPropertyName: "legend", publicName: "legend", isSignal: true, isRequired: false, transformFunction: null }, markers: { classPropertyName: "markers", publicName: "markers", isSignal: true, isRequired: false, transformFunction: null }, noData: { classPropertyName: "noData", publicName: "noData", isSignal: true, isRequired: false, transformFunction: null }, fill: { classPropertyName: "fill", publicName: "fill", isSignal: true, isRequired: false, transformFunction: null }, tooltip: { classPropertyName: "tooltip", publicName: "tooltip", isSignal: true, isRequired: false, transformFunction: null }, plotOptions: { classPropertyName: "plotOptions", publicName: "plotOptions", isSignal: true, isRequired: false, transformFunction: null }, responsive: { classPropertyName: "responsive", publicName: "responsive", isSignal: true, isRequired: false, transformFunction: null }, xaxis: { classPropertyName: "xaxis", publicName: "xaxis", isSignal: true, isRequired: false, transformFunction: null }, yaxis: { classPropertyName: "yaxis", publicName: "yaxis", isSignal: true, isRequired: false, transformFunction: null }, forecastDataPoints: { classPropertyName: "forecastDataPoints", publicName: "forecastDataPoints", isSignal: true, isRequired: false, transformFunction: null }, grid: { classPropertyName: "grid", publicName: "grid", isSignal: true, isRequired: false, transformFunction: null }, states: { classPropertyName: "states", publicName: "states", isSignal: true, isRequired: false, transformFunction: null }, title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, subtitle: { classPropertyName: "subtitle", publicName: "subtitle", isSignal: true, isRequired: false, transformFunction: null }, theme: { classPropertyName: "theme", publicName: "theme", isSignal: true, isRequired: false, transformFunction: null }, autoUpdateSeries: { classPropertyName: "autoUpdateSeries", publicName: "autoUpdateSeries", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["apxChart"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.0", ngImport: i0, type: NgxApexchartsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: "[apxChart]",
                    standalone: true,
                    exportAs: "apxChart",
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }] });

class NgxApexchartsModule {
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.0", ngImport: i0, type: NgxApexchartsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    /** @nocollapse */ static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "20.0.0", ngImport: i0, type: NgxApexchartsModule, imports: [ChartComponent, NgxApexchartsDirective], exports: [ChartComponent, NgxApexchartsDirective] }); }
    /** @nocollapse */ static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "20.0.0", ngImport: i0, type: NgxApexchartsModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.0", ngImport: i0, type: NgxApexchartsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ChartComponent, NgxApexchartsDirective],
                    exports: [ChartComponent, NgxApexchartsDirective],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ChartComponent, NgxApexchartsDirective, NgxApexchartsModule };
//# sourceMappingURL=ngx-apexcharts-signals.mjs.map
